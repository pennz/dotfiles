scriptencoding utf-8
set encoding=utf-8
" vim-bootstrap 

"*****************************************************************************
"" Vim-PLug core
"*****************************************************************************
set nocompatible			" ‰∏ç‰ΩøÁî®viÂÖºÂÆπÊ®°Âºè

let vimplug_exists=expand('~/.config/nvim/autoload/plug.vim')

let $VIRTUAL_ENV = $CONDA_PREFIX
let g:vim_bootstrap_editor = "nvim"				" nvim or vim

if !filereadable(vimplug_exists)
  if !executable("curl")
    echoerr "You have to install curl or first install vim-plug yourself!"
    execute "q!"
  endif
  echo "Installing Vim-Plug..."
  echo ""
  silent exec "!\curl -fLo " . vimplug_exists . " --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"
  let g:not_finish_vimplug = "yes"

  "autocmd VimEnter * PlugInstall
endif

let lite = 0
"let home_path = expand('~')
"if home_path =~ "pengyu"
"  let lite = 1
"endif

nnoremap <SPACE> <Nop>
"" Map leader to <SPACE>
let mapleader="\<SPACE>"
" Required:
call plug#begin(expand('~/.config/nvim/plugged'))

Plug 'vim-scripts/Conque-Shell'
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'
Plug 'tpope/vim-rhubarb' " required by fugitive to :Gbrowse
if isdirectory('/usr/local/opt/fzf')
  Plug '/usr/local/opt/fzf' | Plug 'junegunn/fzf.vim'
else
  Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --bin' }
  Plug 'junegunn/fzf.vim'
endif
Plug 'scrooloose/nerdtree'
Plug 'jistr/vim-nerdtree-tabs'
Plug 'majutsushi/tagbar'
Plug 'easymotion/vim-easymotion'
Plug 'qpkorr/vim-bufkill'
"" Vim-Session
Plug 'xolox/vim-misc'
Plug 'xolox/vim-session'

if has('nvim')
"Plug 'skywind3000/asynctasks.vim'
Plug 'skywind3000/asyncrun.vim'
endif

Plug 'ctrlpvim/ctrlp.vim'
Plug 'Yggdroot/indentLine'

if !lite
"*****************************************************************************
"" Plug install packages
"*****************************************************************************
Plug 'aklt/plantuml-syntax'
Plug 'Joakker/vim-antlr4'
Plug 'tpope/vim-commentary'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'vim-scripts/grep.vim'
Plug 'vim-scripts/CSApprox'
Plug 'Raimondi/delimitMate'
Plug 'w0rp/ale'
Plug 'Yggdroot/indentLine'
Plug 'avelino/vim-bootstrap-updater'
" Default highlight is better than polyglot
let g:polyglot_disabled = ['python']
Plug 'sheerun/vim-polyglot'
Plug 'YorickPeterse/happy_hacking.vim'
Plug 'arzg/vim-colors-xcode'
Plug 'tpope/vim-rsi'
" Add maktaba and codefmt to the runtimepath.
" (The latter must be installed before it can be used.)
Plug 'google/vim-maktaba'
Plug 'google/vim-codefmt'
" Also add Glaive, which is used to configure codefmt's maktaba flags. See
" `:help :Glaive` for usage.
Plug 'google/vim-glaive'

Plug 'ncm2/ncm2'
Plug 'roxma/nvim-yarp'

"Plug 'neoclide/coc.nvim', {'branch': 'release'}

" NOTE: you need to install completion sources to get completions. Check
" our wiki page for a list of sources: https://github.com/ncm2/ncm2/wiki
Plug 'ncm2/ncm2-bufword'
Plug 'ncm2/ncm2-path'
Plug 'HansPinckaers/ncm2-jedi'

let g:make = 'gmake'
if exists('make')
        let g:make = 'make'
endif
Plug 'Shougo/vimproc.vim', {'do': g:make}

if has('nvim')
    Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
    Plug 'deoplete-plugins/deoplete-jedi'
    let g:deoplete#enable_at_startup = 1
  else
    Plug 'Shougo/deoplete.nvim'
    Plug 'roxma/nvim-yarp'
    Plug 'roxma/vim-hug-neovim-rpc'
  endif
  " For Denite features
  Plug 'Shougo/denite.nvim'
  Plug 'davidhalter/jedi-vim'
endif

"" CodeQuery
Plug 'Shougo/unite.vim'
Plug 'devjoe/vim-codequery'

"" Snippets
"Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'


"*****************************************************************************
"" Custom bundles
"*****************************************************************************

" Java
"Plug 'artur-shaik/vim-javacomplete2'
"au FileType java setlocal omnifunc=javacomplete#Complete
""To enable smart (trying to guess import option) inserting class imports with F4, add:
"nmap <F4> <Plug>(JavaComplete-Imports-AddSmart)
"imap <F4> <Plug>(JavaComplete-Imports-AddSmart)
""To enable usual (will ask for import option) inserting class imports with F5, add:
"nmap <F5> <Plug>(JavaComplete-Imports-Add)
"imap <F5> <Plug>(JavaComplete-Imports-Add)
""To add all missing imports with F6:
"nmap <F6> <Plug>(JavaComplete-Imports-AddMissing)
"imap <F6> <Plug>(JavaComplete-Imports-AddMissing)
""To remove all unused imports with F7:
"nmap <F7> <Plug>(JavaComplete-Imports-RemoveUnused)
"imap <F7> <Plug>(JavaComplete-Imports-RemoveUnused)

" tmux
"Plug 'tmux-plugins/vim-tmux-focus-events'
"Plug 'roxma/vim-tmux-clipboard'
Plug 'christoomey/vim-tmux-navigator'

" python
"" Python Bundle
Plug 'tmhedberg/SimpylFold'
Plug 'Chiel92/vim-autoformat'
Plug 'alfredodeza/pytest.vim'
"Plug 'jupyter-vim/jupyter-vim'
Plug 'heavenshell/vim-pydocstring', { 'do': 'make install' }

let g:pydocstring_formatter = 'google'
let g:pydocstring_doq_path = '/usr/local/bin/doq'

nnoremap <leader>ss :PydocstringFormat<CR>
let g:python_style = 'google'
" javascript
Plug 'pangloss/vim-javascript'

" for TypeScript
" REQUIRED: Add a syntax file. YATS is the best
Plug 'HerringtonDarkholme/yats.vim'
Plug 'mhartington/nvim-typescript', {'do': './install.sh; :UpdateRemotePlugins'}

Plug 'raimon49/requirements.txt.vim', {'for': 'requirements'}


" vuejs
"Plug 'posva/vim-vue'
"Plug 'leafOfTree/vim-vue-plugin'

" go
"" Go Lang Bundle
Plug 'fatih/vim-go', {'do': ':GoInstallBinaries'}
Plug 'buoto/gotests-vim'

"*****************************************************************************
"*****************************************************************************

"" Include user's extra bundle
if filereadable(expand("~/.config/nvim/local_bundles.vim"))
  source ~/.config/nvim/local_bundles.vim
endif

call plug#end()

" Required:
filetype plugin indent on


"*****************************************************************************
"" Basic Setup
"*****************************************************************************"
"" Encoding
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8


"" Fix backspace indent
set backspace=indent,eol,start

"" Tabs. May be overridden by autocmd rules
set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab

"" Enable hidden buffers
set hidden

"" Searching
set hlsearch
set incsearch
set ignorecase
set smartcase

set fileformats=unix,dos,mac

if exists('$SHELL')
    set shell=$SHELL
else
    set shell=/bin/sh
endif

" session management
let g:session_directory = "~/.config/nvim/session"
let g:session_autoload = "no"
let g:session_autosave = "no"
let g:session_command_aliases = 1

"*****************************************************************************
"" Visual Settings
"*****************************************************************************
syntax on
"set ruler				" ÊòæÁ§∫Áä∂ÊÄÅÊ†èÂÖâÊ†áÊ†áÂ∞∫
set cursorline				" Á™ÅÂá∫ÊòæÁ§∫ÂΩìÂâçË°å
set number				" ÊòæÁ§∫Ë°åÂè∑
" ÂºÄÂêØËØ≠Ê≥ïÈ´ò‰∫ÆÊòæÁ§∫ÔºåÁªàÁ´ØÊîØÊåÅ256Ëâ≤„ÄÇ
"syntax on
"set t_Co=256

let no_buffers_menu=1
set mousemodel=extend

" the following is for myself
set colorcolumn=80

"let no_buffers_menu=1

"silent! colorscheme xcodedark

"set mousemodel=popup
set t_Co=256
set guioptions=egmrti
set gfn=Monospace\ 10

if has("gui_running")
  if has("gui_mac") || has("gui_macvim")
    set guifont=Menlo:h12
    set transparency=7
  endif
else
  let g:CSApprox_loaded = 1

  " IndentLine
  let g:indentLine_enabled = 1
  let g:indentLine_concealcursor = 0
  let g:indentLine_char = '‚îÜ'
  let g:indentLine_faster = 1

  
endif



"" Disable the blinking cursor.
set gcr=a:blinkon0
set scrolloff=3

"" Status bar
set laststatus=2

"" Use modeline overrides
set modeline
set modelines=10

set title
set titleold="Terminal"
set titlestring=%F

"set statusline=
set statusline=%F%m%r%h%w%=(%{&ff}/%Y)\ (line\ %l\/%L,\ col\ %c)\

" Search mappings: These will make it so that going to the next one in a
" search will center on the line it's found in.
"noremap n nzzzv
"nnoremap N Nzzzv

"if exists("*coc#status")
"  set statusline+=%{coc#status()}
"endif
"if exists("*fugitive#statusline")
"  set statusline+=%{fugitive#statusline()}
"endif

" vim-airline

"func! GetCustomisedText()
"    if exists("*coc#status")
"      echo coc#status() . " Fighting"
"    endif
"endfunc
"
"call airline#parts#define_function('customise_st', 'GetCustomisedText')
"call airline#parts#define_minwidth('customise_st', 150)
"call airline#parts#define_condition('customise_st', 'getcwd() =~ "works"')
"let g:airline_section_y = airline#section#create_right(['ffenc','customise_st'])

let g:airline_theme = 'papercolor'
let g:airline#extensions#branch#enabled = 1
let g:airline#extensions#ale#enabled = 1

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#formatter = "default"
let g:airline#extensions#tabline#tab_nr_type = 1 " tab number
let g:airline#extensions#tabline#show_tab_nr = 1
let g:airline#extensions#tabline#buffer_nr_show = 1
let g:airline#extensions#tabline#fnametruncate = 16
let g:airline#extensions#tabline#fnamecollapse = 2
let g:airline#extensions#tabline#buffer_idx_mode = 1
nmap <leader>1 <Plug>AirlineSelectTab1
nmap <leader>2 <Plug>AirlineSelectTab2
nmap <leader>3 <Plug>AirlineSelectTab3
nmap <leader>4 <Plug>AirlineSelectTab4
nmap <leader>5 <Plug>AirlineSelectTab5
nmap <leader>6 <Plug>AirlineSelectTab6
nmap <leader>7 <Plug>AirlineSelectTab7
nmap <leader>8 <Plug>AirlineSelectTab8
nmap <leader>9 <Plug>AirlineSelectTab9
nmap <leader>- <Plug>AirlineSelectPrevTab
nmap <leader>+ <Plug>AirlineSelectNextTab

let g:airline#extensions#tagbar#enabled = 1
let g:airline_skip_empty_sections = 1

let g:airline#extensions#branch#vcs_priority = ["git", "mercurial"]

let airline#extensions#ale#error_symbol = 'E:'
let airline#extensions#ale#warning_symbol = 'W:'
let airline#extensions#ale#show_line_numbers = 1
let airline#extensions#ale#open_lnum_symbol = '(L'
let airline#extensions#ale#close_lnum_symbol = ')'

let g:airline#extensions#bookmark#enabled = 0
let g:airline#extensions#fugitiveline#enabled = 1

let g:airline#extensions#ctrlp#enabled = 1
let g:airline#extensions#ctrlp#color_template = 'insert' 
"let g:airline#extensions#ctrlp#color_template = 'normal'
"let g:airline#extensions#ctrlp#color_template = 'visual'
"let g:airline#extensions#ctrlp#color_template = 'replace'
let g:airline#extensions#ctrlp#show_adjacent_modes = 1

"*****************************************************************************
"" Abbreviations
"*****************************************************************************
"" no one is really happy until you have this shortcuts
cnoreabbrev W! w!
cnoreabbrev Q! q!
cnoreabbrev Qall! qall!
cnoreabbrev Wq wq
cnoreabbrev Wa wa
cnoreabbrev wQ wq
cnoreabbrev WQ wq
"cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev Qall qall
cnoreabbrev A !java org.antlr.v4.Tool -visitor %
cnoreabbrev G !java org.antlr.v4.gui.TestRig
cnoreabbrev B !javac %:t:r*.java
ca AB copen \| wincmd p \| AsyncRun java org.antlr.v4.Tool -visitor % && javac %:r*.java
cnoreabbrev J !java %:t:r

"" NERDTree configuration
let g:NERDTreeChDirMode=2
let g:NERDTreeIgnore=['\.rbc$', '\~$', '\.pyc$', '\.db$', '\.sqlite$', '__pycache__']
let g:NERDTreeSortOrder=['^__\.py$', '\/$', '*', '\.swp$', '\.bak$', '\~$']
let g:NERDTreeShowBookmarks=1
let g:nerdtree_tabs_focus_on_files=1
let g:NERDTreeMapOpenInTabSilent = '<RightMouse>'
let g:NERDTreeWinSize = 50
set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.pyc,*.db,*.sqlite
nnoremap <silent> <F2> :NERDTreeFind<CR>
nnoremap <silent> <F3> :NERDTreeToggle<CR>

" grep.vim
" nnoremap <silent> <leader>f :Rgrep<CR>
let Grep_Default_Options = '-IR'
let Grep_Skip_Files = '*.log *.db'
let Grep_Skip_Dirs = '.git node_modules'

" terminal emulation
nnoremap <silent> <leader>sh :terminal<CR>


"*****************************************************************************
"" Commands
"*****************************************************************************
" remove trailing whitespaces
command! FixWhitespace :%s/\s\+$//e


"*****************************************************************************
"" Functions
"*****************************************************************************
if !exists('*s:setupWrapping')
  function s:setupWrapping()
    set wrap
    set wm=2
    set textwidth=80
  endfunction
endif

"*****************************************************************************
"" Autocmd Rules
"*****************************************************************************
let b:coc_enabled=0
"CocDisable
autocmd FileType go let b:noNCM2=0 " enable ncm for go
autocmd FileType python let b:noNCM2=0
autocmd FileType * let b:coc_enabled=0
"autocmd FileType * CocDisable

" always enable?
"func! NCM2_enable()
"  if exists('b:noNCM2')
"    return
"  endif
"  call ncm2#enable_for_buffer()
"endfunc
"
"if !lite
"  autocmd BufEnter * call NCM2_enable()
"endif
"" The PC is fast enough, do syntax highlight syncing from start unless 200 lines
augroup vimrc-sync-fromstart
  autocmd!
  autocmd BufEnter * :syntax sync maxlines=200
augroup END

"" Remember cursor position
augroup vimrc-remember-cursor-position
  autocmd!
  autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
augroup END

"" txt
augroup vimrc-wrapping
  autocmd!
  autocmd BufRead,BufNewFile *.txt call s:setupWrapping()
augroup END

"" make/cmake
augroup vimrc-make-cmake
  autocmd!
  autocmd FileType make setlocal noexpandtab
  autocmd BufNewFile,BufRead CMakeLists.txt setlocal filetype=cmake
augroup END

if has('autocmd')
	function! GnuIndent()
		setlocal cinoptions=>4,n-2,{2,^-2,:2,=2,g0,h2,p5,t0,+2,(0,u0,w1,m1
		setlocal shiftwidth=2
		setlocal tabstop=8
	endfunction

	if $VIM_HATE_SPACE_ERRORS != '0'
		let c_space_errors=1
	endif
	au FileType c,cpp setlocal cinoptions=:0,g0,(0,w1 shiftwidth=4 tabstop=4
	au FileType diff setlocal shiftwidth=4 tabstop=4
	au FileType sh setlocal tabstop=4
	au BufEnter /usr/include/* setf c
	au BufEnter /usr/* call GnuIndent()
	"au BufEnter * silent! lcd %:p:h
endif
set autoread
" ÂêØÁî®VIMÂÜÖÁΩÆÁöÑman page reviewerÔºåÂèØ‰ª•Áî®ÂëΩ‰ª§`:Man XXX`Êü•ÁúãÊâãÂÜåÈ°µ
runtime! ftplugin/man.vim
" ### }}} VIM ÁâπÊÄßÈÖçÁΩÆÁªìÊùü

" Show byte offset 
set statusline+=%o
if has('ale')
" ALE linting events
" Move between linting errors
nnoremap ]r :ALENextWrap<CR>
nnoremap [r :ALEPreviousWrap<CR>

augroup ale
  autocmd!

  autocmd VimEnter *
    \ set updatetime=1000 |
    \ let g:ale_lint_on_text_changed = 0
  autocmd CursorHold * call ale#Queue(0)
  autocmd CursorHoldI * call ale#Queue(0)
  autocmd InsertEnter * call ale#Queue(0)
  autocmd InsertLeave * call ale#Queue(0)
augroup END
endif

" When the type of shell script is /bin/sh, assume a POSIX-compatible
" shell for syntax highlighting purposes.
let g:is_posix = 1

set autoread

"*****************************************************************************
"" Mappings
"*****************************************************************************

"" format
noremap <F3> :Autoformat<CR>

"" Split
"noremap <Leader>h :<C-u>split<CR>
noremap <Leader>v :<C-u>vsplit<CR>

"" Git
" Add Gadd
"inoremap <silent> <Leader>ga <ESC> :silent !git add %<CR>
noremap <silent> <Leader>ga :silent !git -C %:p:h add %:p:t<CR>
noremap <Leader>gw :Gwrite<CR>
"noremap <Leader>gc :copen \| wincmd p \| AsyncRun git -C %:p:h commit -sm<SPACE>
noremap <Leader>C :AsyncRun git -C %:p:h commit --no-gpg-sign -sm<SPACE>
noremap <Leader>c :AsyncRun git -C %:p:h commit -sm<SPACE>
noremap <Leader>ggg :copen \| wincmd p \| AsyncRun cd %:p:h && git -C %:p:h add %:p:t && (git commit -sm "Good Game" \|\| true) && git push<CR>
noremap <Leader>gca :Git commit --amend<CR>
noremap <silent> <Leader>gg :copen \| wincmd p \| AsyncRun git -C %:p:h push<CR>
noremap <silent> <Leader>gl :copen \| wincmd p \| AsyncRun git -C %:p:h pull<CR>
noremap <Leader>gs :Git<CR>
noremap <Leader>gb :Git blame<CR>
noremap <Leader>gd :Gvdiff<CR>
noremap <Leader>gr :GRemove<CR>

" session management
nnoremap <leader>so :OpenSession<Space>
nnoremap <leader>sss :SaveSession<Space>
nnoremap <leader>sd :DeleteSession<CR>
nnoremap <leader>sc :CloseSession<CR>

"" Tabs
nnoremap <Tab> gt
nnoremap <S-Tab> gT
nnoremap <silent> <S-t> :tabnew<CR>

"" Set working directory
nnoremap <leader>cd :lcd %:p:h<CR>

"" Opens an edit command with the path of the currently edited file filled in
noremap <Leader>e :e <C-R>=expand("%:p:h") . "/" <CR>

"" Opens a tab edit command with the path of the currently edited file filled
noremap <Leader>te :tabe <C-R>=expand("%:p:h") . "/" <CR>

"" fzf.vim
set wildmode=list:longest,list:full
set wildignore+=*.o,*.obj,.git,*.rbc,*.pyc,__pycache__
let $FZF_DEFAULT_COMMAND =  "find * -path '*/\.*' -prune -o -path 'node_modules/**' -prune -o -path 'target/**' -prune -o -path 'dist/**' -prune -o  -type f -print -o -type l -print 2> /dev/null"

" The Silver Searcher
if executable('ag')
  let $FZF_DEFAULT_COMMAND = 'ag --hidden --ignore .git -g ""'
  set grepprg=ag\ --nogroup\ --nocolor

   " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_user_command = 'ag --literal --files-with-matches --nocolor --hidden -g "" %s'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0

  "if !exists(":Ag")
  "  command -nargs=+ -complete=file -bar Ag silent! grep! <args>|cwindow|redraw!
  "endif
endif

" ripgrep
if executable('rg')
  let $FZF_DEFAULT_COMMAND = 'rg --files --hidden --follow --glob "!.git/*"'
  set grepprg=rg\ --vimgrep
  command! -bang -nargs=* Find call fzf#vim#grep('rg --column --line-number --no-heading --fixed-strings --ignore-case --hidden --follow --glob "!.git/*" --color "always" '.shellescape(<q-args>).'| tr -d "\017"', 1, <bang>0)
endif

let g:fzf_buffers_jump = 1
let g:fzf_commands_expect = 'alt-enter,ctrl-x'
let g:fzf_layout = { 'window': 'enew' }

cnoremap <C-P> <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <silent> <leader>b :Buffers<CR>
nnoremap <silent> <leader>e :FZF -m<CR>
"Recovery commands from history through FZF
nmap <leader>H :History<CR>
" nmap <leader>M :Marks<CR>

" snippets
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<c-b>"
let g:UltiSnipsEditSplit="vertical"


" Tagbar
nmap <silent> <F4> :TagbarToggle<CR>
let g:tagbar_autofocus = 1

" Disable visualbell
set noerrorbells visualbell t_vb=
if has('autocmd')
  autocmd GUIEnter * set visualbell t_vb=
endif

"" Copy/Paste/Cut
if has('unnamedplus')
  set clipboard=unnamed,unnamedplus
endif

noremap YY "+y<CR>
noremap <leader>P "+gP<CR>
noremap XX "+x<CR>

if has('macunix')
  " pbcopy for OSX copy/paste
  vmap <C-x> :!pbcopy<CR>
  vmap <C-c> :w !pbcopy<CR><CR>
endif

"" Buffer nav
noremap <leader>, :bp<CR>
"noremap <leader>q :bp<CR>
noremap <leader>. :bn<CR>
"noremap <leader>w :bn<CR>

"" Close buffer
noremap <leader>x :bd<CR>
""inoremap <leader>c <ESC>:BD<CR>
"noremap <leader>C :BD<CR>

"" Clean search (highlight)
nnoremap <silent> <leader><space> :noh<CR>

"" Switching windows -> controlled by https://github.com/christoomey/vim-tmux-navigator now
" noremap <C-j> <C-w>j
" noremap <C-k> <C-w>k
" noremap <C-l> <C-w>l
" noremap <C-h> <C-w>h
"noremap <C-p> <C-w><C-p>

"" Vmap for maintain Visual Mode after shifting > and <
vmap < <gv
vmap > >gv

"" Move visual block
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv

"" Open current line on GitHub
"nnoremap <Leader>o :.Gbrowse<CR>

"*****************************************************************************
"" Custom configs
"*****************************************************************************\

" python
" vim-python
function! SetPythonOptions()
  setlocal expandtab shiftwidth=4 tabstop=4 colorcolumn=79 formatoptions+=croq softtabstop=4 cinwords=if,elif,else,for,while,try,except,finally,def,class,with
  set errorformat=%f:%l:\ %m
  set makeprg=pylint\ --reports=n\ --msg-template=\"{path}:{line}:\ {msg_id}\ {symbol},\ {obj}\ {msg}\"\ %:p
  nnoremap <Leader>l :copen \| wincmd p \| make <CR>
endfunction

augroup vimrc-python
  autocmd!
  autocmd FileType python call SetPythonOptions()
augroup END

" jedi-vim
let g:jedi#auto_initialization = 1
let g:jedi#popup_on_dot = 1
let g:jedi#popup_select_first = 1
let g:jedi#goto_assignments_command = "<leader>g"
let g:jedi#goto_definitions_command = "<leader>d"
let g:jedi#documentation_command = "K"
let g:jedi#usages_command = "<leader>n"
let g:jedi#rename_command = "<leader>r"
let g:jedi#show_call_signatures = "1"
let g:jedi#completions_command = ""
let g:jedi#smart_auto_mappings = 0
let g:jedi#completions_enabled = 0 " use deoplete-jedi for completions
" deoplete-jedi
let g:deoplete#sources#jedi#enable_typeinfo = 1
let g:deoplete#sources#jedi#ignore_private_members = 1

autocmd FileType java
       \ call deoplete#custom#buffer_option('auto_complete', v:false) | s:coc_setting()
"nnoremap <silent><Leader>dd :<C-u>call deoplete#custom#buffer_option('auto_complete', v:false)<CR>

" typescript related
let g:yats_host_keyword = 1

" ale
let g:ale_linters = {
\   'javascript': ['eslint'],
\   'typescript': ['tsserver', 'tslint'],
\   'vue': ['eslint'],
\   'python': ['pylint','black'],
\   'sh': ['shellcheck'],
\}
let g:ale_python_pylint_executable = '/home/v/miniconda3/envs/pyt/bin/pylint'
let g:ale_fixers = {
\    'javascript': ['eslint'],
\    'typescript': ['prettier'],
\    'vue': ['eslint'],
\    'scss': ['prettier'],
\    'html': ['prettier'],
\    'python': ['add_blank_lines_for_python_control_statements', 'remove_trailing_lines', 'trim_whitespace'],
\    'sh': ['shfmt'],
\}
let g:ale_fix_on_save = 1

" vim-airline
let g:airline#extensions#virtualenv#enabled = 1

" Syntax highlight
let python_highlight_all = 1


" vuejs
" vim vue
let g:vue_disable_pre_processors=1
" vim vue plugin
let g:vim_vue_plugin_load_full_syntax = 1


"*****************************************************************************
"*****************************************************************************

"" Include user's local vim config
if filereadable(expand("~/.config/nvim/local_init.vim"))
  source ~/.config/nvim/local_init.vim
endif

"*****************************************************************************
"" Convenience variables
"*****************************************************************************

" vim-airline
if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

if !exists('g:airline_powerline_fonts')
  let g:airline#extensions#tabline#left_sep = ' '
  let g:airline#extensions#tabline#left_alt_sep = '|'
  let g:airline_left_sep          = '‚ñ∂'
  let g:airline_left_alt_sep      = '¬ª'
  let g:airline_right_sep         = '‚óÄ'
  let g:airline_right_alt_sep     = '¬´'
  let g:airline#extensions#branch#prefix     = '‚§¥' "‚ûî, ‚û•, ‚éá
  let g:airline#extensions#readonly#symbol   = '‚äò'
  let g:airline#extensions#linecolumn#prefix = '¬∂'
  let g:airline#extensions#paste#symbol      = 'œÅ'
  let g:airline_symbols.linenr    = '‚êä'
  let g:airline_symbols.branch    = '‚éá'
  let g:airline_symbols.paste     = 'œÅ'
  let g:airline_symbols.paste     = '√û'
  let g:airline_symbols.paste     = '‚à•'
  let g:airline_symbols.whitespace = 'Œû'
else
  let g:airline#extensions#tabline#left_sep = 'ÓÇ∞'
  let g:airline#extensions#tabline#left_alt_sep = 'ÓÇ±'

  " powerline symbols
  let g:airline_left_sep = 'ÓÇ∞'
  let g:airline_left_alt_sep = 'ÓÇ±'
  let g:airline_right_sep = 'ÓÇ≤'
  let g:airline_right_alt_sep = 'ÓÇ≥'
  let g:airline_symbols.branch = 'ÓÇ†'
  let g:airline_symbols.readonly = 'ÓÇ¢'
  let g:airline_symbols.linenr = 'ÓÇ°'
endif

" from https://thoughtbot.com/blog/vim-splits-move-faster-and-more-naturally
"
" More natural split opening
set splitbelow
set splitright

set autowrite

" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
if (&t_Co > 2 || has("gui_running")) && !exists("syntax_on")
  syntax on
endif

" Display extra whitespace
"set list listchars=tab:¬ª¬∑,trail:¬∑,nbsp:¬∑

" Use one space, not two, after punctuation.
set nojoinspaces

" Tab completion -> mapping use ncm2 suggested one
" https://vimawesome.com/plugin/ncm2
" will insert tab at beginning of line,
" will use completion if not at beginning
"set wildmode=list:longest,list:full
"function! InsertTabWrapper()
"    let col = col('.') - 1
"    if !col || getline('.')[col - 1] !~ '\k'
"        return "\<Tab>"
"    else
"        return "\<C-p>"
"    endif
"endfunction
"inoremap <Tab> <C-r>=InsertTabWrapper()<CR>
"inoremap <S-Tab> <C-n>

" Switch between the last two files
nnoremap <silent><Leader>p :CtrlP<CR>

" Run commands that require an interactive shell
nnoremap <Leader>r :source ~/.vimrc_back<CR>


" Always use vertical diffs
if has('nvim')
    set diffopt+=vertical
endif


""" ### vim ÁâπÊÄßÈÖçÁΩÆ {{{
"set nonu
set relativenumber			" ÊòæÁ§∫Áõ∏ÂØπÔºàÂΩìÂâçÂÖâÊ†áÊâÄÂú®Ë°åÔºâË°åÂè∑ËÄå‰∏çÊòØÁªùÂØπË°åÂè∑
set hlsearch				" È´ò‰∫ÆÊêúÁ¥¢ÁªìÊûú
set incsearch				" ËæìÂÖ•ÊêúÁ¥¢ÂÜÖÂÆπÊó∂Â∞±ÂêåÊ≠•ÊòæÁ§∫ÊêúÁ¥¢ÁªìÊûú
set ignorecase				" ÊêúÁ¥¢Êó∂Â§ßÂ∞èÂÜô‰∏çÊïèÊÑü
set smartcase
set noswapfile
set backupdir=~/.vim/backup/
set directory=~/.vim/swap/
set undodir=~/.vim/undo/
set undofile "undo !!!!!!!!!!!!!
set nowrap				" ÈïøÂ∫¶Ë∂ÖËøáÁ™óÂè£ÂÆΩÂ∫¶‰∏çË¶ÅÊç¢Ë°åÊòæÁ§∫
"set list				" ËÆ©vimÊòæÁ§∫Á©∫Ê†º„ÄÅtab„ÄÅÊç¢Ë°åÁ≠â‰∏çÂèØËßÅÂ≠óÁ¨¶
set listchars=nbsp:¬¨,trail:¬∑,tab:¬ª¬∑	" ËÆæÁΩÆvimÊääÁ©∫Ê†º„ÄÅÊç¢Ë°å„ÄÅtabÊòæÁ§∫‰∏∫‰ªÄ‰πàÂ≠óÁ¨¶
set gcr=a:blinkon0
set scrolloff=3				" ÂÖâÊ†áÁßªÂä®Âà∞È°∂ÈÉ®ÂíåÂ∫ïÈÉ®Êó∂Ëá™Âä®‰øùÊåÅ3Ë°åË∑ùÁ¶ª
"set showmatch				" ÊòæÁ§∫Ëá™Âä®ÂåπÈÖçÂà∞ÁöÑÂØπÂ∫îÊã¨Âè∑
set showmode				" ËÆ©vimÂú®Á™óÂè£ÊúÄ‰Ωé‰∏ãÊòæÁ§∫ÂΩìÂâçÊ®°ÂºèÔºåÂ¶Ç--insert--Á≠â
set showcmd				" Âú®ÂëΩ‰ª§Ê®°Âºè‰∏ãËæìÂÖ•ÂëΩ‰ª§Êó∂ÔºåÂêåÊ≠•ÊòæÁ§∫Â∑≤ÁªèÈîÆÂÖ•ÁöÑÂëΩ‰ª§ÂÜÖÂÆπ
set nobackup				" ‰øùÂ≠òÊñá‰ª∂Êó∂Ôºå‰∏çË¶ÅÂàõÂª∫Â§á‰ªΩÊñá‰ª∂
"set textwidth=0				" ‰∏ÄË°åÂÜÖËæìÂÖ•Â≠óÁ¨¶ËææÂà∞Â§öÂ∞ëÊó∂Ëá™Âä®Êç¢Ë°åÔºå0Ë°®Á§∫‰∏çÈôêÂà∂
set history=500				" ËÆ∞ÂΩïÁöÑÂéÜÂè≤ÂëΩ‰ª§‰∏™Êï∞

set shiftwidth=4			" ËÆæÂÆövimÁöÑËá™Âä®Áº©ËøõÔºå‰ª•Âèä>Âíå<ÂëΩ‰ª§Êó∂ÁßªÂä®ÁöÑÁ©∫ÁôΩÈïøÂ∫¶
set softtabstop=0			" Êåâ‰∏ãtabÊó∂ÔºåÊèíÂÖ•ÁöÑÊòØÁ©∫Ê†ºÂíåtabÂà∂Ë°®Á¨¶ÁöÑÊ∑∑ÂêàÔºåÂÖ∑‰ΩìÊñπÂºèÂèÇËßÅ:help softtabstop
set tabstop=4				" ËÆæÂÆötabÈïøÂ∫¶‰∏∫4Â≠óËäÇ
set expandtab				" ÈîÆÂÖ•tabÊó∂ÔºåËá™Âä®Áî®Á©∫Ê†ºÊõøÊç¢tabÔºåÁ©∫Ê†ºÈïøÂ∫¶Á≠â‰∫étabstopÁöÑËÆæÁΩÆ

set backspace=indent,eol,start		" ÈÄÄÊ†ºÈîÆÔºàbackspaceÔºâÈªòËÆ§Â∑•‰ΩúviÊ®°Âºè‰∏ã„ÄÇËØ•ËÆæÁΩÆÂèØ‰ª•ËÆ©ÈÄÄÊ†ºÈîÆÂ∑•‰ΩúÂú®Â§ßÂÆ∂ÁÜüÊÇâÁöÑÊñπÂºè‰∏ã„ÄÇ
					" indent: Â¶ÇÊûúËÆæÁΩÆ‰∫Ü:set indentÁ≠âËá™Âä®Áº©ËøõÔºåÊåâÈÄÄÊ†ºÈîÆ‰ºöÂà†ÊéâËøô‰∏™Áº©Ëøõ„ÄÇ
					" eol: Â¶ÇÊûúÊèíÂÖ•Ê®°Âºè‰∏ãÂú®Ë°åÂºÄÂ§¥ÔºåËÆæÁΩÆ‰∫ÜeolÂêéÊåâ‰∏ãÈÄÄÊ†ºÈîÆ‰ºöÂêàÂπ∂Âà∞‰∏ä‰∏ÄË°å„ÄÇ
					" start: Ëã•‰∏çËÆæÁΩÆ‰∏∫startÔºåÂàôÂú®ÂõûÈÄÄÊó∂ÔºåÂè™ËÉΩÂõûÈÄÄÂà†Èô§Ëá™Â∑±Êñ∞Ê∑ªÂä†ÁöÑÂ≠óÁ¨¶ÔºåÂéüÊù•Â∑≤ÁªèÂ≠òÂú®ÁöÑÂ≠óÁ¨¶Êó†Ê≥ïÂõûÈÄÄÂà†Èô§„ÄÇ
" set pastetoggle=<f3>			" Êåâ‰∏ãf3ÈîÆÂèØ‰ª•ÂàáÊç¢Á≤òË¥¥ÊèíÂÖ•Ê®°Âºè[insert (paste)]ÂíåÊôÆÈÄöÊèíÂÖ•Ê®°Âºè„ÄÇ

" easy motion
nnoremap <Leader>em <Plug>(easymotion-prefix)


"" Vmap for maintain Visual Mode after shifting > and <
vmap < <gv
vmap > >gv

"" Move visual block
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv

" mouse
set mouse=nv

" Jump to next error with Ctrl-n and previous error with Ctrl-m. Close the
" quickfix window with <leader>a
map <C-n> :cnext<CR>
"map <C-m> :cprevious<CR>


" <Leader>f{char} to move to {char}
"map  <Leader>f <Plug>(easymotion-bd-f)
"nmap <Leader>f <Plug>(easymotion-overwin-f)

" s{char}{char} to move to {char}{char}
"nmap s <Plug>(easymotion-overwin-f2)

" Move to line
"map <Leader>L <Plug>(easymotion-bd-jk)
"nmap <Leader>L <Plug>(easymotion-overwin-line)

" Move to word
"map  <Leader>w <Plug>(easymotion-bd-w)
nmap <Leader>w <Plug>(easymotion-overwin-w)

let g:SimpylFold_docstring_preview = 1

" swith between python and ipynb filetype
"noremap <Leader>p :set filetype=python<CR>
"noremap <Leader>j :set filetype=ipynb<CR>  # always called by accident

let g:python3_host_prog  = system('cd $(git rev-parse --show-toplevel) && PPath="$(poetry env info -p)" && test -n $PPath && echo $PPath/bin/python3 || which python3')[:-2]
let g:python_host_prog  = system('cd $(git rev-parse --show-toplevel) && PPath="$(poetry env info -p)" && test -n $PPath && echo $PPath/bin/python || which python')[:-2]
"let g:python_host_prog = expand('~') . "/.nix-profile/bin/python"
"let g:python3_host_prog = expand('~') . "/.nix-profile/bin/python3"

"set fillchars=stl:^,stlnc:=,vert:‚îÇ,fold:¬∑,diff:-
"noremap <Leader>x :bunload<CR>

function! BufSel(pattern)
  let bufcount = bufnr("$")
  let currbufnr = 1
  let nummatches = 0
  let firstmatchingbufnr = 0
  while currbufnr <= bufcount
    if(bufexists(currbufnr))
      let currbufname = bufname(currbufnr)
      if(match(currbufname, a:pattern) > -1)
        echo currbufnr . ": ". bufname(currbufnr)
        let nummatches += 1
        let firstmatchingbufnr = currbufnr
      endif
    endif
    let currbufnr = currbufnr + 1
  endwhile
  if(nummatches == 1)
    execute ":buffer ". firstmatchingbufnr
  elseif(nummatches > 1)
    let desiredbufnr = input("Enter buffer number: ")
    if(strlen(desiredbufnr) != 0)
      execute ":buffer ". desiredbufnr
    endif
  else
    echo "No matching buffers"
  endif
endfunction

"Bind the BufSel() function to a user-command
command! -nargs=1 Bs :call BufSel("<args>")
noremap <Leader>bs :Bs<SPACE>

" Customized mapping...
"vnoremap jk <ESC>
"vnoremap fd <ESC>
inoremap jk <ESC>
inoremap fd <ESC>
inoremap <C-z> <ESC>
noremap \ :Rg<SPACE>
"inoremap <Leader>s <ESC>:w<CR>
nnoremap <Leader>s <ESC>:w<CR>
"inoremap <Leader>ss <C-O>:w<CR>
"inoremap <silent> <Leader>S <ESC>:silent wq<CR><CR>
noremap <Leader>s :<C-U>w<CR>
noremap <silent> <Leader>S :<C-U>silent wq<CR><CR>
nnoremap <silent> <leader>F :Files<CR>
nnoremap <silent> <leader>t :Tags<CR>
nnoremap <silent> <leader>rg       :Rg <C-R><C-W><CR>
xnoremap <silent> \       y:Rg <C-R><C-W><CR>

if !lite
" Optional: Enable codefmt's default mappings on the <Leader>= prefix.
"Glaive codefmt plugin[mappings]
call glaive#Install()

let gjf = expand('~/bin/google-java-format-1.7-all-deps.jar')
if !filereadable(gjf)
    let gje = 'Glaive codefmt google_java_executable='. "\"java -jar " . gjf . "\""
    execute gje
endif
endif
nnoremap Q gq$
nnoremap <silent> <Leader>= :FormatCode<CR>
imap <C-w> <C-o><C-w>
noremap <M-<> <C-W><
noremap <M->> <C-W>>

if has('cscope')
  set cscopetag cscopeverbose

  if has('quickfix')
    set cscopequickfix=s-,c-,d-,i-,t-,e-
  endif

  cnoreabbrev csa cs add
  cnoreabbrev csf cs find
  cnoreabbrev csk cs kill
  cnoreabbrev csr cs reset
  cnoreabbrev css cs show
  cnoreabbrev csh cs help

  command! -nargs=0 Cscope cs add $VIMSRC/src/cscope.out $VIMSRC/src
endif

command! W :execute ':silent w !sudo tee % > /dev/null' | :edit!

set pastetoggle=<F6>

" formatter
autocmd FileType typescript setlocal formatprg=prettier\ --parser\ typescript

" LANG: go
" vim-go
" run :GoBuild or :GoTestCompile based on the go file
function! s:build_go_files()
  let l:file = expand('%')
  if l:file =~# '^\f\+_test\.go$'
    call go#test#Test(0, 1)
  elseif l:file =~# '^\f\+\.go$'
    call go#cmd#Build(0)
  endif
endfunction

let g:go_list_type = "quickfix"
let g:go_fmt_command = "goimports"
let g:go_fmt_fail_silently = 1

let g:go_highlight_types = 1
let g:go_highlight_fields = 1
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1
let g:go_highlight_structs = 1
let g:go_highlight_generate_tags = 1
let g:go_highlight_space_tab_error = 1
let g:go_highlight_array_whitespace_error = 0
let g:go_highlight_trailing_whitespace_error = 0
let g:go_highlight_extra_types = 1

let g:go_info_mode = 'gopls'
let g:go_def_mode = 'gopls'
let g:go_referrers_mode = 'gopls'

autocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4 softtabstop=4
autocmd BufNewFile,BufRead *.dart setlocal noexpandtab tabstop=2 shiftwidth=2 softtabstop=2

augroup completion_preview_close
  autocmd!
  if v:version > 703 || v:version == 703 && has('patch598')
    autocmd CompleteDone * if !&previewwindow && &completeopt =~ 'preview' | silent! pclose | endif
  endif
augroup END

augroup go

  au!
  au Filetype go command! -bang A call go#alternate#Switch(<bang>0, 'edit')
  au Filetype go command! -bang AV call go#alternate#Switch(<bang>0, 'vsplit')
  au Filetype go command! -bang AS call go#alternate#Switch(<bang>0, 'split')
  au Filetype go command! -bang AT call go#alternate#Switch(<bang>0, 'tabe')

  au FileType go nmap <Leader>dd <Plug>(go-def-vertical)
  au FileType go nmap <Leader>dv <Plug>(go-doc-vertical)
  au FileType go nmap <Leader>db <Plug>(go-doc-browser)

  au FileType go nmap <leader>r  <Plug>(go-run)
  au FileType go nmap <leader>t  <Plug>(go-test)
  au FileType go nmap <Leader>gt <Plug>(go-coverage-toggle)
  au FileType go nmap <Leader>i <Plug>(go-info)
  au FileType go let g:jedi#documentation_command = ""
  au FileType go nnoremap <silent>K :GoDoc <BAR> wincmd p<CR>
  au FileType go nmap <silent> <Leader>l <Plug>(go-metalinter)
  au FileType go nmap <C-g> :GoDecls<cr>
  au FileType go nmap <leader>dr :GoDeclsDir<cr>
  au FileType go imap <C-g> <esc>:<C-u>GoDecls<cr>
  au FileType go imap <leader>dr <esc>:<C-u>GoDeclsDir<cr>
  au FileType go nmap <leader>rb :<C-u>call <SID>build_go_files()<CR>

augroup END

let g:go_doc_popup_window = 0
let g:go_doc_keywordprg_enabled = 1
" ale
call extend(g:ale_linters, {
    \"go": ['golint', 'gopls', 'go vet'], })

nnoremap <Leader>a :copen <BAR> wincmd p <BAR> AsyncRun<SPACE>

" -------------------------------------------------------------------------------------------------
" coc.nvim default settings
" -------------------------------------------------------------------------------------------------

" if hidden is not set, TextEdit might fail.
set hidden
" Better display for messages
set cmdheight=2
" Smaller updatetime for CursorHold & CursorHoldI
set updatetime=300
" don't give |ins-completion-menu| messages.
set shortmess+=c
" always show signcolumns
set signcolumn=yes

func! s:coc_setting()
" Use tab for trigger completion with characters ahead and navigate.
" Use command ':verbose imap <tab>' to make sure tab is not mapped by other plugin.
	inoremap <silent><expr> <TAB>
		  \ pumvisible() ? "\<C-n>" :
		  \ <SID>check_back_space() ? "\<TAB>" :
		  \ coc#refresh()
	inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

	function! s:check_back_space() abort
	  let col = col('.') - 1
	  return !col || getline('.')[col - 1]  =~# '\s'
	endfunction

	" Use <c-space> to trigger completion.
	inoremap <silent><expr> <c-space> coc#refresh()

	" Use `[c` and `]c` to navigate diagnostics
	nmap <silent> [c <Plug>(coc-diagnostic-prev)
	nmap <silent> ]c <Plug>(coc-diagnostic-next)

	" Remap keys for gotos
	nmap <silent> gd <Plug>(coc-definition)
	nmap <silent> gy <Plug>(coc-type-definition)
	nmap <silent> gi <Plug>(coc-implementation)
	nmap <silent> gr <Plug>(coc-references)

	" Use U to show documentation in preview window
	nnoremap <silent> U :call <SID>show_documentation()<CR>

	" Remap for rename current word
	nmap <leader>rn <Plug>(coc-rename)

	" Remap for format selected region
	vmap <leader>f  <Plug>(coc-format-selected)
	nmap <leader>f  <Plug>(coc-format-selected)
	" Show all diagnostics
	nnoremap <silent> <space>a  :<C-u>CocList diagnostics<cr>
	" Manage extensions
	nnoremap <silent> <space>e  :<C-u>CocList extensions<cr>
	" Show commands
	nnoremap <silent> <space>c  :<C-u>CocList commands<cr>
	" Find symbol of current document
	nnoremap <silent> <space>o  :<C-u>CocList outline<cr>
	" Search workspace symbols
	nnoremap <silent> <space>s  :<C-u>CocList -I symbols<cr>
	" Do default action for next item.
	nnoremap <silent> <space>j  :<C-u>CocNext<CR>
	" Do default action for previous item.
	nnoremap <silent> <space>k  :<C-u>CocPrev<CR>
	" Resume latest coc list
	nnoremap <silent> <space>p  :<C-u>CocListResume<CR>
endfunc

" for complition
" neocomplete like
" deoplete.nvim recommend
" added for ncm2
set completeopt=noinsert,noselect,menuone
" deoplete-go settings
"let g:deoplete#sources#go#gocode_binary = $GOPATH.'/bin/gopls'
let g:deoplete#sources#go#sort_class = ['package', 'func', 'type', 'var', 'const']


let g:ctrlp_user_command = 'find %s -type f'        " MacOSX/Linux
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']

"let g:jedi#force_py_version = 2  " conda plugin recommend
let g:UltisnipsUsePythonVersion = 2
let g:conda_startup_msg_suppress = 1

" other ncm2 settings
set shortmess+=c
inoremap <c-c> <ESC>
let ncm2#popup_delay = 5
let ncm2#complete_length = [[1, 1]]
" Use new fuzzy based matches
let g:ncm2#matcher = 'substrfuzzy'
inoremap <expr> <CR> (pumvisible() ? "\<c-y>\<cr>" : "\<CR>")

" Use <TAB> to select the popup menu:
inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

" wrap existing omnifunc
" Note that omnifunc does not run in background and may probably block the
" editor. If you don't want to be blocked by omnifunc too often, you could
" add 180ms delay before the omni wrapper:
"  'on_complete': ['ncm2#on_complete#delay', 180,
"               \ 'ncm2#on_complete#omni', 'csscomplete#CompleteCSS'],
au User Ncm2Plugin call ncm2#register_source({
		\ 'name' : 'css',
		\ 'priority': 9,
		\ 'subscope_enable': 1,
		\ 'scope': ['css','scss'],
		\ 'mark': 'css',
		\ 'word_pattern': '[\w\-]+',
		\ 'complete_pattern': ':\s*',
		\ 'on_complete': ['ncm2#on_complete#omni', 'csscomplete#CompleteCSS'],
		\ })

" escape from terminal
tnoremap <Esc> <C-\><C-n>

set lazyredraw
let g:go_version_warning = 0
nnoremap <silent><Leader>h :<C-u>if 1 == winnr('$') <BAR> bd <BAR> else <BAR> hide <BAR> endif <CR>
nnoremap <silent><Leader>M :<C-u>only<CR>

" Define mappings
autocmd FileType denite call s:denite_my_settings()
function! s:denite_my_settings() abort
  nnoremap <silent><buffer><expr> <CR>
  \ denite#do_map('do_action')
  nnoremap <silent><buffer><expr> d
  \ denite#do_map('do_action', 'delete')
  nnoremap <silent><buffer><expr> p
  \ denite#do_map('do_action', 'preview')
  nnoremap <silent><buffer><expr> q
  \ denite#do_map('quit')
  nnoremap <silent><buffer><expr> i
  \ denite#do_map('open_filter_buffer')
  nnoremap <silent><buffer><expr> <Space>
  \ denite#do_map('toggle_select').'j'
endfunction

" META KEYS: timeout for keys mappings
set timeout
set ttimeout
set tm=250

" KEY MAPPING
func! BufSwitch()
  let buflist = []
  let bufdict = {}
  let bufcount = bufnr("$")
  let currbufnr = 1
  let numexists = 0
  let firstmatchingbufnr = 0
  let previous_buf_deleted = 1
  let pn = bufnr("#")
  let cnr = bufnr("%")

  while currbufnr <= bufcount
    if(bufexists(currbufnr) && bufloaded(currbufnr))
      "echo numexists . "/" . currbufnr . ": ". bufname(currbufnr)
      let bufdict[numexists] = currbufnr
      let numexists = numexists + 1
      call add(buflist, currbufnr)
      if pn == currbufnr
        let previous_buf_deleted = 0
      endif
    endif
    let currbufnr = currbufnr + 1
    "echo currbufnr
  endwhile
  if(numexists <= 1)
    CtrlP
  else
    if pn == cnr || previous_buf_deleted == 1
      if cnr == buflist[0]
          bn
      else
          bp
      endif
    else
      if @# =~ "NERD" || @# == "" || @# =~ "^__" || @# =~ "term"
        " if it is the fist buf
        if cnr == buflist[0]
          echo "bn"
          bn
        else
          echo "bp"
          bp
        endif
      else
        echo "edit " . @#
        edit #
      endif
    endif
  endif
endfunc

func! BufDelete()
  let @" = bufnr("")
  call BufSwitch()
  if @# =~ "NERD" || @# == ""
    "echo "buffer not good, try close\" b" . @" . " EOL"
    bd "
  else
    echo "buffer not good, try close\" b" . @" . " EOL"
    "let @" = pn
    bd #
  endif
  let @#=bufnr("")
endfunc

nnoremap <silent><Leader>m :make<CR>
nnoremap <silent><Leader>E :e ~/.vimrc_back<CR>
"noremap <silent><Leader>p :<C-u>wincmd p<CR>
nnoremap <silent><Leader><Leader> :call BufSwitch()<CR>
nnoremap <leader>D :<C-u>let @#="<C-R>#" <BAR> keepalt BD<CR>
nnoremap <leader>dd :keepalt bd<CR>
nnoremap <leader>ddd :<C-u>bd!<CR>
nnoremap <silent><leader>dd :call BufDelete()<CR>
vnoremap <Leader><Leader><Leader> <ESC>

"" Include user's local vim config
if filereadable(expand("~/.rc.local"))
  source ~/.rc.local
endif

func! s:cclose_on_good()
    if g:asyncrun_status == 'success'
        echo g:asyncrun_code
        cclose
    else
        echo "ERROR. Please check."
    endif
endfunc

let g:asyncrun_open = 6
let g:asyncrun_save = 1
autocmd User AsyncRunStop call s:cclose_on_good()

" copy from pasky
"""" Core stuff

"version 5.0

set nocompatible " has to be on the first line

"set modeline
set nomodeline
"set modelines=3

set exrc

"let mapleader="~" " make sure this is done before any <Leader> stuff happens

" turned on for pytest
filetype on
filetype plugin on  
filetype indent on
"
set nobackup
set viminfo='20,\"50

" Otherwise, contents of last visual will appear in X11 selection buffer - eek!
set clipboard=unnamedplus


"""" Charset
set fencs=ucs-bom,utf-8,default,latin2


"""" Autocompletion

set wildchar=<Tab>
set wildmenu
"set wildmode=longest:full,full
"
"set history=200


"""" Searching

"set ignorecase
"set smartcase
"set hlsearch
"set incsearch
"
"
""""" Indentation
"
"set shiftwidth=8
"
"set cindent
set smartindent
set autoindent


"""" Formatting

"set formatoptions=cql12
set formatoptions=cqj12

"set list listchars=tab:\ \ ,trail:-

" If you don't want it for B&W terminals, but you do want it for color terminals, put this in your .vimrc:
if &t_Co > 1
  syntax on
endif


"""" Folding

set foldmethod=indent
set foldenable
set foldlevel=99


"""" Tags

set tags=./tags,tags,./TAGS,TAGS,tags,TAGS,../tags,../TAGS,../../tags,../../TAGS,../../../tags,../../../TAGS,../../../../tags,../../../../TAGS,../../../../../tags,../../../../../TAGS,../../../../../../tags,../../../../../../TAGS,../../../../../../../tags,../../../../../../../TAGS,../../../../../../../../tags,../../../../../../../../TAGS,../../../../../../../../../tags,../../../../../../../../../TAGS,../../../../../../../../../../tags,../../../../../../../../../../TAGS,../../../../../../../../../../../tags,../../../../../../../../../../../TAGS,../../../../../../../../../../../../tags,../../../../../../../../../../../../TAGS,/usr/include/tags,/usr/include/TAGS,/usr/local/include/tags,/usr/local/include/TAGS



"""" User mapping (misc)

" v) "`"'	visual content quoted
vnoremap "" <esc>:set paste<cr>`>a"<c-o>`<"<esc>:set nopaste<cr>`>2l
vnoremap "' <esc>:set paste<cr>`>a'<c-o>`<'<esc>:set nopaste<cr>
vnoremap "` <esc>:set paste<cr>`>a`<c-o>`<`<esc>:set nopaste<cr>

" v) "<>[](){}	visual content parenthesed
vnoremap "< <esc>:set paste<cr>`>a><c-o>`<<<esc>:set nopaste<cr>
vnoremap "> <esc>:set paste<cr>`>a><c-o>`<<<esc>:set nopaste<cr>`>2l
vnoremap "[ <esc>:set paste<cr>`>a]<c-o>`<[<esc>:set nopaste<cr>
vnoremap "] <esc>:set paste<cr>`>a]<c-o>`<[<esc>:set nopaste<cr>`>4l
vnoremap "( <esc>:set paste<cr>`>a)<c-o>`<(<esc>:set nopaste<cr>
vnoremap ") <esc>:set paste<cr>`>a)<c-o>`<(<esc>:set nopaste<cr>`>2l
vnoremap "{ <esc>:set paste<cr>`>a}<c-o>`<{<esc>:set nopaste<cr>
vnoremap "} <esc>:set paste<cr>`>a}<c-o>`<{<esc>:set nopaste<cr>`>2l

" v> ">		visual content mail-quoted
" TODO: autocommand for mails only!
vnoremap "> :s/^/> <cr>:nohl<cr>
vnoremap ". :s/^/> <cr>:nohl<cr>

" v> "#		visual content shelloidically commented out
vnoremap "# :s/^/# <cr>:nohl<cr>
vnoremap "3 :s/^/# <cr>:nohl<cr>

" v> "*		visual content C-commented out
vnoremap "* <esc>:set paste<cr>`>a */<c-o>`</* <esc>:set nopaste<cr>

" v> m-c	cd to directory given in the visual
" FIXME: doesn't work when ^M is at the end (line visual)!
" !!  is ascii 27, ESC key
vnoremap c y:cd "\|pwd<cr>

" n> m-h	hide highlight
noremap h :nohl<cr>

" n> L          light background
"noremap L :set bg=light<cr> " conflict with L goto bottom of the screen

" v) m-yY	gradual yank - first use m-Y and then m-y, it is accumulated into "a register
"		just use p to put it eventually; you don't have to pre-select "a register
vmap y "Ay
vmap Y "ay

"ni> m-p	paste/nopaste switch
nmap p :set paste!<cr>:set paste?<cr>
imap p <esc>pa
" set pastetoggle=p " might colide with CtrlP if pressed accidently [ too...

" n> s		split line at the place of cursor
"nmap s i<cr><c-c>

" n> S		insert blank line after the current line
nmap S o<c-c>

" n> m-S	insert blank line in front of the current line
nmap S O<c-c>

" n> &		highlight word under cursor
nmap & *N

" n> m-n	reformat buglist in glibc NEWS
"noremap n <ap:set tw=74<cr>gqapkvip:left 2<cr>:set tw&<cr>


"" Buffer switching

map <A-1> :b1<CR>
map <A-2> :b2<CR>
map <A-3> :b3<CR>
map <A-4> :b4<CR>
map <A-5> :b5<CR>
map <A-6> :b6<CR>
map <A-7> :b7<CR>
map <A-8> :b8<CR>
map <A-9> :b9<CR>
map <A-0> :b10<CR>
map <C-Tab> :bn<CR>
map <S-C-Tab> :bp<CR>




"""" User mapping (misc ex commands)
"command! Pohelp :new /opt/vim/share/vim/vim61/ftplugin/po.vim|:set readonly



"""" Per-filetype mapping

au BufEnter *vimrc set keywordprg=
au BufLeave *vimrc set keywordprg=man

au FileType perl set formatoptions=cql

au! BufNewFile,BufRead *.ino setlocal ft=arduino
au! BufNewFile,BufRead *.pde setlocal ft=arduino
au! BufNewFile,BufRead *.md setlocal ft=markdown



"""" UI

"" I/O
"set mouse=
"set bg=dark
"set bg=light
set bs=2

set ttimeout ttimeoutlen=10 " esc v insert modu ma okamzitou odezvu

"set statusline=%{VimBuddy()}

set noruler

"" Windows
set noequalalways

"" Buffers
set switchbuf=useopen

"" GUI
set guifont=Monospace\ 9

"" Grep in QuickFix
autocmd QuickFixCmdPost *grep* cwindow

"" Auto-close preview when leaving insert mode (after completion)
autocmd InsertLeave * if pumvisible() == 0|pclose|endif



"""" Plugins

""" Pathogen
"execute pathogen#infect()
"" Ctrl-P
let g:ctrlp_user_command =
    \ ['.git', 'cd %s && git ls-files . -co --exclude-standard']
"" Gundo
nnoremap U :GundoToggle<CR>
"" Syntastic -> we use ALE
" let g:syntastic_mode_map = { 'mode': 'active',
"                         \ 'passive_filetypes': ['java', 'markdown'] }
" let g:syntastic_cpp_compiler_options = ' -std=gnu++11'
" let g:syntastic_python_flake8_args = '--ignore="E226,E501,F403"'
" let g:syntastic_python_flake8_args = '--ignore="E226,E501,F403"'
" let g:syntastic_python_python_exec = 'python3'
"" Eclim
let g:EclimCValidate = 0
let g:EclimCppValidate = 0
let g:EclimXmlIndentDisabled = 0  " no indentation is actually done with the eclim-shipped xml indent?!
let g:EclimLoggingDisabled = 1  " trouble with class hierarchies where the ancestor also has a logger
"" jedi
"let g:jedi#goto_assignments_command = '<cr>'
let g:jedi#use_tabs_not_buffers = "0"
let g:jedi#use_splits_not_buffers = "bottom"
let g:jedi#popup_on_dot = 0
let g:pymode_rope = 0

""" Prehistoric

"" Increment

" c-A in visual mode works as gradual incrementation
vnoremap <c-a> :Inc<CR>


"" Calendar

let g:calendar_mark='right'
let g:calendar_navi='both'
let g:calendar_monday=1


"" EnhancedCommentify

let g:EnhCommentifyPretty = 'Yes'
let g:EnhCommentifyRespectIdent = 'Yes'
let g:EnhCommentifyUseAltKeys = 'Yes'


"" MiniBufExplorer
let g:miniBufExplSplitBelow=1


"" VimSpell

"let spell_language_list = "english,czech"
""highlight SpellErrors ctermbg=Red guibg=Red ctermfg=White guifg=White cterm=underline gui=underline term=reverse
"highlight link SpellErrors Error

"" TeX
let g:tex_flavor = "latex"

"" SQL
" This is something purely evil, hijacking C-C.
let g:omni_sql_no_default_maps = 1



"""" Sourcing standalone rcs

"so /home/pasky/.vimrc.shell



" turned on for pytest
filetype on
filetype plugin on  
filetype indent on

noremap <silent><leader>tf :Pytest file<CR>
noremap <silent><leader>tc :Pytest class<CR>
noremap <silent><leader>M :wincmd \| <BAR> wincmd _<CR>

let g:go_debug=['shell-commands']
let g:loaded_node_provider=0

" https://thoughtbot.com/blog/vim-spell-checking
autocmd BufRead,BufNewFile *.md setlocal spell spelllang=en_us
autocmd FileType gitcommit setlocal spell
set complete+=kspell

nnoremap <Leader>o :on<CR>
hi Visual term=reverse cterm=reverse guibg=Grey
nmap <silent><Leader>tf <Esc>:Pytest file<CR>
nmap <silent><Leader>tc <Esc>:Pytest class<CR>
nmap <silent><Leader>tm <Esc>:Pytest method<CR>
nmap <silent><Leader>ts <Esc>:Pytest session<CR>
